//NMEA-0183 library.  
//1/ open nmea.h and change  #include "WConstants.h"  to  #include "arduino.h"  
//2/ Open nmal.cpp and change  #include "WProgram.h"  to  #include "arduino.h"  


#include <SoftwareSerial.h>                   //this is for debugging purposes, once the product is tested succesfully, it will be removed
#include <nmea.h>                             //library to decode the sonar's messages
#include "MS5837.h"                           //library to operate the pressure sensor
#include <Wire.h>                             //library to connect to the pressure sensor

SoftwareSerial tempSerial(10, 11);            //assign new RX, TX pins for debugging
NMEA nmeaDecoder(ALL);
MS5837 presSensor;                            //create the pressure sensor data structure
const int xPin = 5;                           //x output of the accelerometer
const int yPin = 6;                           //y output of the accelerometer

const int updatePin = 2;                      //set the mode interrupt pin
const int manualPin = 3;                      //set the manual mode interrupt pin
const int modePin1 = 7;                       //set the mode pins
const int modePin2 = 8;
const int modePin3 = 9;
volatile int buoyMode = -1;                   //set the mode to default
volatile bool manualMode = false;             //set manual mode off

const int valveEntrance = 12;                 //set the pins for valve control
const int valveExit = 13;

int n = 3;                                    //rank of the depth information in the NMEA sentence
float fSonarDepth = 0;                        //init sonar depth to 0
float fPresDepth = 0;                         //init pressure sensor depth to 0
int pulseX, pulseY;                           //init the output of the accelerometer (PMW pulses)
int accelX, acceleY;                          //init acceleration of the system (in milli-g's)

void setup() {
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
  
  tempSerial.begin(4800);                     //initialize the serial port (REPLACE tempSerial by Serial AFTER debugging)
  Wire.begin();                               //initialize the I2C communication
  
  while (!sensor.init()) {                    //blink the onboard LED while initialising the sensor
    digitalWrite(LED_BUILTIN, HIGH);
    delay(250);
    digitalWrite(LED_BUILTIN, LOW);
    delay(250);
  }
  digitalWrite(LED_BUILTIN, LOW);             //reset the LED to off
  
  sensor.setModel(MS5837::MS5837_30BA);       //set the pressure sensor type
  sensor.setFluidDensity(1029);               //water density in kg/m^3 (997 for freshwater, 1029 for seawater)
  
  //initialise the mode pins
  pinMode(modePin1, INPUT_PULLUP);
  pinMode(modePin2, INPUT_PULLUP);
  pinMode(modePin3, INPUT_PULLUP);
  
  //initialise the interrupt pin to change buoyancy modes
  pinMode(updatePin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(updatePin), updateMode, RISING);
  
  //initialise the interrupt pin to switch to manual mode
  pinMode(manualPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(manualPin), manualStart, RISING);
  
  //initialise the valve control pins
  pinMode(valveEntrance, OUTPUT);
  pinMode(valveExit, OUTPUT);
  
  sonar();                                    //initialize the recorded values
  pressure();
  acceleration();
}   

void loop() {
  //update the sensor data
  sonar();
  pressure();
  acceleration();
  
  //check for manual override
  if (!manualMode){
    //perform buoyancy adjustments according to mode
    switch (buoyMode){
      //negative buoyancy (lowering)
      case 0:

        break;

      //neutral buoyancy (level)
      case 1:

        break;

      //positive buoyancy (rising)
      case 2:

        break;

      //initial (do nothing)
      case -1:
        break;
    }
  }
  else{
    //read the manual pin, if it is low, disable manual mode
    if (digitalRead(manualPin) == LOW) {
      manualMode = false;
    }
  }
}

void sonar() {
  //SONAR READ
  if (tempSerial.available()) {               // if something is incoming through the Serial Port
    if (nmeaDecoder.decode(Serial2.read())) { // if it's a valid NMEA sentence
      char* cDepth = nmeaDecoder.term(n);     //extract the nth term (depth)
      fDepth = atof(cDepth);                  //convert it to float
    }
  }
}

void pressure() {
  //PRESSURE SENSOR READ
  sensor.read();                              //update the sensor state
  fPresDepth = sensor.depth();                //update the recorded depth
}

void acceleration() {
  //ACCELEROMETER READ
  pulseX = pulseIn(xPin, HIGH);               //read the pulse length for the x and y axes
  pulseY = pulseIn(yPin, HIGH);
  accelX = ((pulseX / 10) - 500) * 8;         //compute the acceleration value in milli-g's
  accelY = ((pulseY / 10) - 500) * 8;
}

void updateMode() {
  //read the mode pins
  bool down = (digitalRead(modePin1) == HIGH);
  bool neutral = (digitalRead(modePin2) == HIGH);
  bool up = (digitalRead(modePin3) == HIGH);
  
  bool error = false;
  
  //set flag for correct mode
  if(down){
    buoyMode = 0;
  }
  else if(neutral){
    buoyMode = 1;
  }
  else if(up){
    buoyMode = 2;
  }
  else{
    error = true;                             //if none of the buttons have been recorded set error flag
  }
  
  //shut both electrovalves
  valveShut(0);
  
  //set LED for correct mode ? (flash if error ?)
  
}

void manualStart() {
  //shut both electrovalves
  valveShut(0);
  
  //set flag for manual control
  manualMode = true;
  
  //set LED for manual control ?
  
}

void valveShut(int i) {
  switch (i){
    //shut both valves
    case 0:
      digitalWrite(valveEntrance, LOW);
      digitalWrite(valveExit, LOW);
      break;
    
    //shut entrance valve
    case 1:
      digitalWrite(valveEntrance, LOW);
      break;
    
    //shut exit valve
    case 2:
      digitalWrite(valveExit, LOW);
      break;
  }
}

void valveOpen(int i) {
  switch (i){
    //open both valves
    case 0:
      digitalWrite(valveEntrance, HIGH);
      digitalWrite(valveExit, HIGH);
      break;
    
    //open entrance valve
    case 1:
      digitalWrite(valveEntrance, HIGH);
      break;
    
    //open exit valve
    case 2:
      digitalWrite(valveExit, HIGH);
      break;
  }
}
